.dagger:
  image: mikebrown008/ci-cli-base:0.5
  variables:
    MINIO: s3.waw3-2.cloudferro.com
    BUCKET: registry-inference-server-controller-dev
    GITLAB: git.apps.eo4eu.eu
    REPO_NAMESPACE: eo4eu/eo4eu-inference-server
    HELM_NAMESPACE: eo4eu/eo4eu-cicd/cicd-infra
    REGISTRY: registry.apps.eo4eu.eu
    REPO: controller
    SERVICE: eo4eu-inference-server
    HELM: helm-repo
    COOKIECUTTER_BRANCH: inference-server-controller
  rules:
  - if: $CI_COMMIT_BRANCH == "main"
    variables: 
      REPO_BRANCH: main
      HELM_BRANCH: main
      CLUSTER: cineca-inference-server
  - if: $CI_COMMIT_BRANCH == "dev"
    variables:
      REPO_BRANCH: dev
      HELM_BRANCH: dev
      CLUSTER: cineca-inference-server
  - if: $CI_COMMIT_BRANCH == "backup"
    variables:
      REPO_BRANCH: backup
      HELM_BRANCH: backup
      CLUSTER: ecmwf-inference-server
  - if: $CI_COMMIT_BRANCH == "dev-backup"
    variables:
      REPO_BRANCH: dev-backup
      HELM_BRANCH: dev-backup
      CLUSTER: ecmwf-inference-server
  before_script:
    - "apk --no-cache add jq kubectl"
    - "export VAULT_TOKEN=$(curl -s -X PUT \
      -d '{\"role_id\":\"'$VAULT_ROLE_ID'\",\"secret_id\":\"'$VAULT_SECRET_ID'\"}' \
      \"$VAULT_SERVER_URL/v1/auth/approle/login\" | \
      jq -r '.auth.client_token')"
    - "export BEARER=\"X-Vault-Token: $VAULT_TOKEN\""
    - "export CI_REPO_USERNAME=$(curl -s -H \"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/eo4eu-cicd/gitlab_credentials/$SERVICE/$REPO\" | \
      jq -r '.data.data.username')"
    - "export CI_REPO_PASSWORD=$(curl -s -H \"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/eo4eu-cicd/gitlab_credentials/$SERVICE/$REPO\" | \
      jq -r '.data.data.password')"
    - "export CI_COOKIECUTTER_USERNAME=$(curl -s -H \"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/gitlab_credentials/cookiecutter-repo\" | \
      jq -r '.data.data.username')"
    - "export CI_COOKIECUTTER_PASSWORD=$(curl -s -H \"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/gitlab_credentials/cookiecutter-repo\" | \
      jq -r '.data.data.password')"
    - "export CI_HELM_USERNAME=$(curl -s -H \"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/gitlab_credentials/$HELM\" | \
      jq -r '.data.data.username')"
    - "export CI_HELM_PASSWORD=$(curl -s -H \"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/gitlab_credentials/$HELM\" | \
      jq -r '.data.data.password')"
    - "export S3_ACCESS_KEY=$(curl -s -H \"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/s3_cloudferro_creds/gitlab\" | \
      jq -r '.data.data.s3_access_key')"
    - "export S3_SECRET_KEY=$(curl -s -H \"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/s3_cloudferro_creds/gitlab\" | \
      jq -r '.data.data.s3_secret_key')"
    - "curl -s -H \"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/eo4eu-cicd/kubeconfigs/$CLUSTER\" | \
      jq -r '.data.data.kubeconfig' > /builds/$REPO_NAMESPACE/$REPO/kubeconfig"
    - "git clone -b $REPO_BRANCH \
      https://$CI_REPO_USERNAME:$CI_REPO_PASSWORD@$GITLAB/$REPO_NAMESPACE/$REPO.git"
    - "git clone -b $HELM_BRANCH \
      https://$CI_HELM_USERNAME:$CI_HELM_PASSWORD@$GITLAB/$HELM_NAMESPACE/$HELM.git"
    - "export TAG=$(git -C $REPO rev-parse HEAD)"
    - "export KUBECONFIG=/builds/$REPO_NAMESPACE/$REPO/kubeconfig"
update_endpoint:
  extends: [.dagger]
  tags: [dagger]
  stage: .pre
  script:
    - cd $REPO
    - | 
      if git diff HEAD~1 | grep -Eq '^(-  kafka_source_endpoint:)'; then
        export KAFKA_ENDPOINT=$(grep 'kafka_source_endpoint:' \
          cookiecutter-config.yaml | \
          awk '{print $2}' | tr -d '"')
        find build -type f -exec sed -i \
          's/\(\s*"bootstrapServers": "\)\(.*\)/\1'"$KAFKA_ENDPOINT"'",/g' {} \;
        find build -type f -exec sed -i \
          's/\(\s*"bootstrapServers": \["\)\(.*\)/\1'"$KAFKA_ENDPOINT"'"\],/g' {} \;
        git config user.email "federico.fornari@ecmwf.int"
        git config user.name "Cookiecutter"
        git add --all
        git commit -m "Updated kafka endpoint by Cookiecutter" || true
        git push -o ci.skip
      fi
build_image:
  extends: [.dagger]
  tags: [dagger]
  stage: build
  needs: [update_endpoint]
  script:
    - cd $REPO
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^(build/)'; then
        dagger call build \
        --bucket $BUCKET \
        --endpoint https://$MINIO \
        --access env:S3_ACCESS_KEY \
        --secret env:S3_SECRET_KEY \
        --repo $REPO \
        --tag $TAG \
        --wkd build
      fi
scan_image:
  extends: [.dagger]
  tags: [dagger]
  stage: test
  needs: [build_image]
  dependencies: [build_image]
  script:
    - cd $REPO
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^(build/)'; then
        dagger call scan \
        --bucket $BUCKET \
        --endpoint https://$MINIO \
        --access env:S3_ACCESS_KEY \
        --secret env:S3_SECRET_KEY \
        --severity UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL \
        --exit 0 \
        --repo $REPO \
        --tag $TAG \
        --wkd /builds/$REPO_NAMESPACE/$REPO \
        export \
        --path \
        /builds/$REPO_NAMESPACE/$REPO/vulnerabilities.html
      fi
  artifacts:
    when: always
    expire_in: 4 weeks
    paths:
      - vulnerabilities.html
push_image:
  extends: [.dagger]
  tags: [dagger]
  stage: deploy
  needs: [scan_image]
  script:
    - cd $REPO
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^(build/)'; then
        dagger call push \
          --bucket $BUCKET \
          --endpoint https://$MINIO \
          --access env:S3_ACCESS_KEY \
          --secret env:S3_SECRET_KEY \
          --registry $REGISTRY \
          --namespace $REPO_NAMESPACE \
          --repo $REPO \
          --srctag $TAG \
          --dsttag $TAG \
          --username $CI_REPO_USERNAME \
          --password env:CI_REPO_PASSWORD \
          --wkd build
      fi
clean_revisions:
  extends: [.dagger]
  tags: [dagger]
  stage: .post
  needs: [push_image]
  script:
    - cd $REPO
    - |
      export CHART_SERVICE=$(grep 'service_name:' cookiecutter-config.yaml | \
        awk '{print $2}' | tr -d '"')
    - |
      export CHART_NAMESPACE=$(grep 'chart_name:' cookiecutter-config.yaml | \
        awk '{print $2}' | tr -d '"')
    - |
      if git diff HEAD~1 | grep -Eq '^(\+  service_min_scale: "0")' && \
         git diff HEAD~1 | grep -Eq '^(\+  service_disable_autoscaling: "true")' && \
         git diff HEAD~1 | grep -Eq '^(\+  chart_version:)'; then
        kubectl -n $CHART_NAMESPACE \
          delete revision \
          -lserving.knative.dev/configuration=$CHART_SERVICE
      fi
update_helm:
  extends: [.dagger]
  tags: [dagger]
  stage: .post
  needs: [clean_revisions]
  artifacts:
    untracked: true
  script:
    - cd $REPO
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^(build/)'; then
        sed -i 's/\(  service_image_tag: "\)\(.*\)/\1'"$TAG"'"/g' cookiecutter-config.yaml
        git config user.email "federico.fornari@ecmwf.int"
        git config user.name "Cookiecutter"
        git add --all
        git commit -m "Updated image tag by Cookiecutter" || true
        git push -o ci.skip
      fi
    - dagger call update
      --gitlab $GITLAB
      --repo $REPO
      --branch $COOKIECUTTER_BRANCH
      --username $CI_COOKIECUTTER_USERNAME
      --password env:CI_COOKIECUTTER_PASSWORD
      --wkd .
      export
      --path
      /builds/$REPO_NAMESPACE/$REPO/$SERVICE-helm
sync_helm:
  extends: [.dagger]
  tags: [dagger]
  stage: .post
  needs: [update_helm]
  dependencies: [update_helm]
  artifacts:
    untracked: true
  script:
    - rm -rf $HELM/$SERVICE-$REPO
    - cp -r /builds/$REPO_NAMESPACE/$REPO/$SERVICE-helm $HELM/$SERVICE-$REPO
    - cd $HELM
    - git config user.email "federico.fornari@ecmwf.int"
    - git config user.name "Cookiecutter"
    - git add --all
    - git commit -m "Updated helm chart by Cookiecutter" || true
    - git push
clean_registry:
  extends: [.dagger]
  tags: [dagger]
  stage: .post
  script:
    - cd $REPO
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^(build/)'; then
        dagger call clean \
        --bucket $BUCKET \
        --endpoint https://$MINIO \
        --access env:S3_ACCESS_KEY \
        --secret env:S3_SECRET_KEY
      fi